# 如何写一个功能的后端设计方案

**为什么要写方案？**

写方案的目的是为了帮助我们想清楚需求，更好的落地需求。

并且记录实现的初衷，**后续方便进行迭代。**我们经常会说之前的人没留下文档，导致很多时候都是通过代码来猜测功能的意图，导致最后很多代码我们不敢删，一直堆积在那里。

后续接手的人同样会产生疑问，“为什么之前迭代不删掉这部分代码？”

代码是这样一步一步堆积出来的，我们在这个过程中就要不断地往熵减的方向去努力，降低系统的整体复杂度。

再通过方案跨组评审的方式，可以帮助我们思考**通用性和复用点**。

比如有些问题可能在其他组已经遇到了，我们就可以直接借鉴他们成熟的代码。

如果这个过程中能够看到可以抽离服务的内容，那独立成服务进行维护后，健壮性也会上升一个等级，后续需要相似功能的人就不再需要过分担心这部分代码的稳定性。

先通过一张思维导图来快速预览一下整体的内容：

![Untitled](../../../backend-design/Untitled.png)

接下具体看看每个点在写方案的过程中，会重点写哪些内容，来帮助我们完成一个具体的项目需求

# 一.需求背景

## 1.1 业务背景

需求背景一定是在最开头，要阐释清楚做这个的产品**需求背景、业务痛点**。

例如项目起因、业务方预期。**产品是为了解决什么样的问题才需要引入这个需求的**，如果后续某个产品功能下线后，对应的痛点也不存在了，则对应的需求也无需保留。

**不然最后是否要保留需求都不知道，只会让代码越积重难返。**

## 1.2 技术目标

还要了解这个需求所容纳的数据量的大小，如果是否有时效性的限制。

比如一个活动需求，它的时效性仅服务于每年的活动，并且每一年的活动形式可能不相同，所以是一个临时性的需求，但是由于是活动，所以 QPS 有可能会比常规功能高。

这就引出了对应需求的限制，在后续技术方案的设计中会十分关键

- 数据具有时效性和完整性
- 峰值QPS可能会高比常规流量高，这个可以根据产品的用户量给出实际的估算值，比如会有多少人参与活动

# 二.系统架构设计

## 2.1 业务架构

**通过时序图划分清楚边界以及调用**，新增或改动现有接口调用时，重点分析调用场景和链路，可以帮助我们发现性能隐患.

如果是新功能设计，能够帮助我们理清系统边界，明确后续用例应该在哪个系统内进行实现。

## 2.2 核心状态机

在业务流程比较复杂时，需要引入状态机来标识实体的状态，则需要明确画出状态机转换是是什么动作触发的，对应的动作则是我们是需要实现的用例。

比如支付订单创建后，用户支付后会流转成已支付等待发货，或者时超时支付则订单关闭解锁库存等，都是需要在状态机中体现出来，这也是为了后续实现的时候管理好整体流程。

# 三.存储方案设计

## 3.1 数据库设计

主要包含以下三个内容：

1. **核心领域模型的ER图**，这一部分帮我们梳理清楚满足需求所需要的实体内容。
2. 对应数据库表具体的**字段含义以及索引的设计：**索引的设计对于查询来说十分重要，一个好的索引，可能是亿级别的数据存储下，能够不出现慢查询，甚至不需要进行分库分表，单表就能应付巨大的业务量。
3. **读写分离、分库分表和冷热分离等的设计：**这部分如果在业务量大的时候需要重点分析，难点主要在于哪些是频繁读写的热数据，通过数据分级的方式，不同的数据存储在不同的介质中，这样不仅**提高了程序的性能，也降低了应用整体部署的成本。**

## 3.2 缓存设计

缓存资源占用的预估，如果占用资源过多，那么需要对缓存淘汰策略进行设计。

哪些数据需要进行缓存？为什么这些数据需要缓存？

缓存数据多久算多？缓存的更新策略是怎么样的？

存储需要的内存和成本，怎么进行估算的？

**数据预热**

服务预热一般包含

- **应用程序缓存预热**：把一些数据预先加载到内存中。
- **分布式缓存预热**：将数据预先加载到redis。
- **数据库预热**：预先初始化一些数据库数据，避免实时计算。

比如有些产品需求要达到一个列表展示的目的，但是由于数据分库表和分业务团队负责的原因，没办法简单做分页逻辑，则需要增加中间层对数据进行聚合。然后根据不同的性能指标、数据量来选择不同的聚合方案。

## 3.3 消息队列

削峰填谷是消息队列最主要的作用，就是将峰值流量平均分配到应用非热门时段去进行处理。

这里的设计最需要区分的点是数据处理的**实时性要求**，可以将实时性分成以下三类

**1.实时**

比如用户付钱款或者操作订单状态变更，这种都是需要实时去确认结果的，所以都是在API 操作完成返回的时候就已经持久化好了数据结果。

**2.近实时**

这种操作一般是用户不需要立即看到结果或者无需在页面展示的，比如确定收货后，货款是否立即打到对方的账户上，这个操作牵涉到多个系统，同步调用耗时无法接受，但是也不允许过长时间未处理，所以可以放在消息队列中去进行处理

但是这里处理也要区分，有些队列任务并不需要非常高的时效，那么对应的队列消费者也不需要太多，可以通过队列消费者个数来控制下游消费速度，并且通过队列消息堆积来看是否在可控范围内。

**3.离线**

这种一般属于数据统计和报表类需求，基本是天级别的数据延迟，

![Untitled](../../../backend-design/Untitled%201.png)

## 3.4 对象存储

> 对象存储是一种以非结构化格式（称为对象）存储和管理数据的技术
> 

图片、文件等通过对象存储进行资源访问，以什么样的数据存储在库中，如果需要切换对象存储域名，是否方便进行替换。

# 四.服务应用设计

## 4.1 异步化 — 更多的是一个实现细节，功能设计可以体现

应用服务本身怎么做异步化？

比如服务如果数据操作逻辑没有顺序问题，则可以通过并发操作来完成。如果出现了错误，是要全部失败返回，还是缺失部分信息就可以？

并发的好处显而易见，就是让整个**操作的时长等于最长的那一个，而不是所有操作时长相加。**

![Untitled](../../../backend-design/Untitled%202.png)

但是这里也需要注意一个问题，会不会给服务造成过大的TPS和QPS？

**如果并发度是8，一个操作增加了并发逻辑之后，最高可能会把QPS 放大八倍**，这个时候如果并发的操作都是在不同的微服务上，那也只是流量等比例打过去而已，而如果有三个操作在同一个微服务上，相当于**下游的服务承受了放大三倍的流量**，在大促的时候，这有可能就是压垮系统的一个潜在问题。

所以在并发设计的时候，要**特别去说明哪些要进行并发**，并让相关方评估流量是否能够承受，是否需要给下游的微服务增加物理资源，避免出现功能在测试环境没问题，但是上线后流量增大导致功能异常。

## 4.3 API 设计

这里包含不仅包含了给客户端的前端的API ，如果涉及到微服务之间的调用，还需要提供服务间调用的接口协议，比如 `protobuf` 等

# 五.上线方案

## 6.1 部署方案

如果涉及到多个服务，注意**服务发布的顺序**

比如有异步任务处理的 Job 进程，是否需要先进行部署，部署之后是否能够接任原来 Pod的任务，旧任务能否兼容。

多个微服务之间是否有相互调用的依赖关系，如果相互依赖，则要规定好本次发布的顺序，切忌出现服务间的循环依赖，**因为不同 Pod的更新我们没有办法控制它们同时变成新版本。**

如果出现循环依赖，则需要看是否是应用层级划分是否需要更细，比如有些内容是否需要继续拆解成更小的微服务或者是异步处理任务，而不是都靠同步操作实现。

如果涉及到数据库变更，要看是否对现在的数据有影响，比如增加索引，是否会有锁表的风险。

**表结构改变了之后，尽量不要立刻删除原来的字段，等迭代一段时间稳定之后，再逐步进行删除。**

## 6.2 灰度方案

出现问题了的话需要回滚，回滚的方案是怎么样的，需要回滚哪些内容

数据库的库表是否需要回滚，**如何回滚？是否会产生脏数据，应该如何处理？**

发布的应用哪些需要回滚？**回滚的顺序是怎么样的？是否有副作用？**

这部分回滚需要考虑新旧逻辑是否兼容，**被新应用操作的数据旧应用是否还能继续**

## 6.3 数据迁移&兼容

如果在一个需求内涉及到将旧数据初始化到新表中，则需要先设计好数据迁移方案，比如上线前是否需要脚本先迁移旧的数据，然后增量数据则通过线上代码改造成双写写入数据库中，避免中间有数据缺失，然后通过数据比对来看新数据是否已经达到可用的标准。

最后在一系列操作完成之后，是否需要将原有双写方案的旧数据操作下线，减轻数据库压力，整个都需要有详细的计划，如果无法对资源进行回收，也会给成本带来很大的压力。